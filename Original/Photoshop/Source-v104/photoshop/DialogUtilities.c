/*	File: DialogUtilities.c	Copyright 1993-6 by Adobe Systems, Inc.	C source file for plug-in dialog utilities.*/#include "DialogUtilities.h"/*****************************************************************************//* The following routine locates the QuickDraw globals. */QDGlobals *GetQDGlobals (void)	{		return (QDGlobals *) ((* (char **) SetCurrentA5 ()) -									(sizeof (QDGlobals) - sizeof (GrafPtr)));		}/*****************************************************************************//* Set the cursor to the arrow cursor. */void SetArrowCursor ()	{		QDGlobals *qd = GetQDGlobals ();		SetCursor (&(qd->arrow));		}/*****************************************************************************//* Centers a dialog template 1/3 of the way down on the main screen. */void CenterDialog (DialogTHndl dt)	{	#define MenuHeight 20	Rect screenBounds = (*GetMainDevice())->gdRect;	short width = screenBounds.right - screenBounds.left;	short height = screenBounds.bottom - screenBounds.top;	Rect dialogBounds = (**dt).boundsRect;	OffsetRect (&dialogBounds, -dialogBounds.left, -dialogBounds.top);	OffsetRect (&dialogBounds, (width - dialogBounds.right) / 2,					(height - dialogBounds.bottom - MenuHeight) / 3 + MenuHeight);	(**dt).boundsRect = dialogBounds;		#undef menuHeight	}/*****************************************************************************//* Test for Adobe Moveable Modal Dialog if running System 6 */void SetUpMoveableModal (DialogTHndl dt, OSType hostSig)	{	long	response = 0x0700;		if (Gestalt (gestaltSystemVersion, &response) != noErr)		response = 0;		if (response < 0x0700)		{	/* Prior to System 7... */		Handle	windRes = nil;				/* We don't have to release the resource, because opening the		   dialog will do the right thing with it if it exists. */		if (hostSig == '8BIM')			windRes = GetResource ('WDEF', PSmovableDBoxProc/16);					if (windRes != NULL)			(*dt)->procID = PSmovableDBoxProc;		else			(*dt)->procID = dBoxProc;		/* not moveable, sorry */		}			}/*****************************************************************************/typedef struct ModalData	{		long oldRefCon;		ModalFilterProcPtr filter;		ProcessEventProc processEvent;		} ModalData;/*****************************************************************************//* Some handy ASCII values for keystrokes */#define RETURN	0x0D#define ENTER	0x03#define PERIOD	'.'#define ESCAPE	0x1B#define	TAB		'\t'/*****************************************************************************//* Event filter to allow movable modal dialogs. */static pascal Boolean DialogFilter (DialogPtr dp,									EventRecord *event,									short *item)	{	Boolean result = FALSE;	GrafPtr savePort;		ModalData *data = (ModalData *) GetWRefCon (dp);		if (data->filter)		{				SetWRefCon (dp, data->oldRefCon);				result = (*data->filter) (dp, event, item);				data->oldRefCon = GetWRefCon (dp);				SetWRefCon (dp, (long) data);				if (result)			return TRUE;				}		if (event->what == mouseDown)		{		/* We have to do window-dragging ourselves */		Point pt = event->where;		WindowPtr window;		if (FindWindow (pt, &window) == inDrag && window == dp)			{			Rect bounds = (*GetGrayRgn())->rgnBBox;			InsetRect (&bounds, 4, 4);			DragWindow (window, pt, &bounds);			event->what = nullEvent;			}		}	else if (event->what == keyDown && FALSE) // don't do this		{		/* We have to do button key-equivalents ourselves, now, too */		char ch = event->message & charCodeMask;		if (ch == RETURN || ch == ENTER)			{			*item = ok;			FlashDialogButton (dp, ok);			result = TRUE;			}		else if (ch == ESCAPE || (ch == PERIOD && (event->modifiers & cmdKey)))			{			*item = cancel;			FlashDialogButton (dp, cancel);			result = TRUE;			}		else if (ch == TAB && (event->modifiers & shiftKey))			{						// select previous item						}		}		else if (event->what == updateEvt || event->what == activateEvt)		{		/* Pass updates and activates out to the host */		if (data->processEvent && (event->message != ((long) dp)))			(*data->processEvent) (event);		}	else if (event->what == nullEvent)		{		/* Let the host idle */		if (data->processEvent)			(*data->processEvent) (event);		}			GetPort (&savePort);	SetPort (dp);			result = StdFilterProc (dp, event, item);		SetPort (savePort);	return result;	}/*****************************************************************************/#ifdef __powercstatic RoutineDescriptor DialogFilterRDS =BUILD_ROUTINE_DESCRIPTOR(uppModalFilterProcInfo, &DialogFilter);#define DialogFilterRD (&DialogFilterRDS)#else#define DialogFilterRD (&DialogFilter)#endif/*****************************************************************************/void MoveableModalDialog (DialogPtr dp,						  ProcessEventProc processEvent,						  ModalFilterProcPtr filter,						  short *item)	{		ModalData data;		data.oldRefCon = GetWRefCon (dp);	data.filter = filter;	data.processEvent = processEvent;		SetWRefCon (dp, (long) &data);		ModalDialog (DialogFilterRD, item);		SetWRefCon (dp, data.oldRefCon);		}/*****************************************************************************/long GetMoveableWRefCon (DialogPtr dp)	{		ModalData *data = (ModalData *) GetWRefCon (dp);		return data->oldRefCon;		}/*****************************************************************************/short ShowAlert (short alertID){		Handle alertHandle;	short result;		alertHandle = GetResource ('ALRT', alertID);	HNoPurge (alertHandle);		CenterDialog ((DialogTHndl) alertHandle);		result = Alert (alertID, nil);		HPurge (alertHandle);	return result;	}/*****************************************************************************/short ShowVersionAlert (Handle hDllInstance,						short alertID, 						short stringID,						Str255 versText1,						Str255 versText2){		short 			result = 0;	Handle			alertHandle = NULL;	Str255			ds = "";	StringHandle	h = 0;		if (alertID)	{				if (stringID > 0)		{			h = GetString(stringID);			if (h) 			{				AppendString(ds, *h, 1, *h[0]);				ReleaseResource((Handle)h);			}		}				alertHandle = GetResource('ALRT', alertID);		HNoPurge (alertHandle);			CenterDialog ((DialogTHndl) alertHandle);			PIParamText(ds, NULL, versText1, versText2);		ParamText (ds, NULL, NULL, NULL);				result = CautionAlert (alertID, nil);			HPurge (alertHandle);	}	return result;}/*****************************************************************************/short ShowAlertType (Handle hDllInstance,				     short alertID, 				     short stringID, 				     Str255 minText, 				     Str255 maxText,				     short alertType){		short 			result = 0;	Handle			alertHandle = NULL;	Str255			ds = "";	StringHandle	h = 0;		if (alertID)	{				if (stringID > 0)		{			h = GetString(stringID);			if (h) 			{				AppendString(ds, *h, 1, *h[0]);				ReleaseResource((Handle)h);			}		}				alertHandle = GetResource('ALRT', alertID);		HNoPurge (alertHandle);			CenterDialog ((DialogTHndl) alertHandle);			PIParamText(ds, NULL, minText, maxText);		ParamText (ds, NULL, NULL, NULL);				switch (alertType)		{			case PIAlertCaution:				result = CautionAlert (alertID, nil);				break;			case PIAlertStop:				result = StopAlert (alertID, nil);				break;		}			HPurge (alertHandle);	}	return result;}/*****************************************************************************/void ShowAbout (OSType hostSign, short dialogID){	short 			item;	DialogPtr 		dp;	DialogTHndl 	dt;	StringHandle	h;		h = GetString(dialogID);		dt = (DialogTHndl) GetResource ('DLOG', dialogID);	HNoPurge ((Handle) dt);	CenterDialog (dt);	SetUpMoveableModal (dt, hostSign);	dp = GetNewDialog (dialogID, nil, (WindowPtr) -1);		ParamText (*h, NULL, NULL, NULL);		SetArrowCursor ();		(void) SetDialogDefaultItem (dp, ok); // hidden	(void) SetDialogCancelItem (dp, ok); // either	MoveableModalDialog (dp, NULL, NULL, &item);			DisposDialog (dp);	ReleaseResource((Handle)h); // DisposeHandle(Handle(h))	HPurge ((Handle) dt);}/*****************************************************************************//* UserItem to outline a button group box, except for top text */static pascal void OutlineGroup (DialogPtr dp, short item)	{	Rect	 r, rText;	Handle	 h;	short	 itemType;	PenState originalPenState;	GetPenState (&originalPenState);	GetDialogItem (dp, item+1, &itemType, &h, &rText);	/* bounds ofsurrounding text */	GetDialogItem (dp, item,   &itemType, &h, &r);		/* the group box */		PenNormal ();	PenSize (1, 1);		MoveTo (rText.right, r.top);	LineTo (r.right, r.top);	LineTo (r.right, r.bottom);	LineTo (r.left, r.bottom);	LineTo (r.left, r.top);	LineTo (rText.left, r.top);		SetPenState (&originalPenState);		}/*****************************************************************************/#ifdef __powercstatic RoutineDescriptor OutlineGroupRDS =	BUILD_ROUTINE_DESCRIPTOR(uppUserItemProcInfo, &OutlineGroup);#define OutlineGroupRD (&OutlineGroupRDS)#else#define OutlineGroupRD (&OutlineGroup)#endif/*****************************************************************************//* The following routine sets a user item to be a group box.  It expects   the next item to be the title for the group box. */void SetOutlineGroup (DialogPtr dp, short groupItem)	{		short itemType;	Rect r;	Handle h;	GetDialogItem (dp, groupItem, &itemType, &h				     , &r);	SetDialogItem (dp, groupItem,  itemType, (Handle) OutlineGroupRD, &r);		}/*****************************************************************************//* The following routine selects an edit text item. */void SelectTextItem (DialogPtr dp, short item)	{		SelIText (dp, item, 0, 32767);		}/*****************************************************************************//* The following routine sets the text of a text item. */void StuffText (DialogPtr dp, short item, Str255 text)	{		Rect r;	short itemType;	Handle textHdl;		GetDialogItem (dp, item, &itemType, &textHdl, &r);		SetDialogItemText (textHdl, text);		}/*****************************************************************************//* The following routine extracts the text of a text item. */void FetchText (DialogPtr dp, short item, Str255 text)	{		Rect r;	short itemType;	Handle textHdl;		GetDialogItem (dp, item, &itemType, &textHdl, &r);		GetDialogItemText (textHdl, text);		}	/*****************************************************************************//* The following routine stuffs a numeric value into a text field. */void StuffNumber (DialogPtr dp, short item, long value)	{		Str255 s;			NumToString (value, s);		StuffText (dp, item, s);		}/*****************************************************************************//*    Here is the corresponding routine to retrieve the value from a text   field.  It will do range checking and validate that it has been   handed a number.       It returns TRUE if it gets a valid value in the field. */   short FetchNumber (DialogPtr dp,					short item,					long min,					long max,					long *value){			Str255 s = "";	long x = 0;	short retn = noErr;		FetchText (dp, item, s);		if (!StringToNumber (s, &x))	{		x = 0;		retn = errNotANumber;	}	else if (x < min || x > max) retn = errOutOfRange;		*value = x;	return retn;}/*****************************************************************************//* Here is the accompanying alert mechanism for a text field.   If it has not been handed a number, it brings up   an appropriate error dialog, inserts an appropriately pinned value,   and selects the item.     It returns TRUE if it gets a valid value in the field. */ void AlertNumber (DialogPtr dp,				  short item,				  long min,				  long max,				  long *value,				  Handle hDllInstance,		 		  short alertID,		 		  short numberErr){	Str255 minText = "";	Str255 maxText = "";	long x = *value;		x = (x < min ? min : max);	*value = x;		StuffNumber (dp, item, x);	NumToString(min, minText);	NumToString(max, maxText);		(void) ShowCaution (hDllInstance,						alertID,				  	    kBadNumberID, // could use numberErr==errNotANumber						minText,	  // to pop a "that's not a number"						maxText);	  // alert.			SelectTextItem (dp, item);}/*****************************************************************************//* The following routine stuffs a double into a text field. */void StuffDouble (DialogPtr dp, short item, double value, short precision){	Str255 	s;	DoubleToString(value, s, precision);	StuffText(dp, item, s);}/*****************************************************************************//*    Here is the corresponding routine to retrieve the floating value from a text   field.  It will do range checking and validate that it has been   handed a number.      It returns noErr if it gets a valid value. */   short FetchDouble (DialogPtr dp,					short item,					double min,					double max,					double *value){	Str255 s1 = "";	Str255 s2 = "";			long x1 = 0;	long x2 = 0;	short precision = 0;	Boolean notAWholeNumber = false;	Boolean notADecimalNumber = false;	Boolean notANumber = false;	double x = 0;	short retn = noErr;		FetchText (dp, item, s1);		DivideAtDecimal(s1, s2);		notAWholeNumber = !StringToNumber (s1, &x1);		notADecimalNumber = !StringToNumber (s2, &x2);		precision = s2[0]; //length		notANumber = (notAWholeNumber && notADecimalNumber);		x = (double)x1 + ((double)x2 / (double)power(10, s2[0]));		if (notANumber)	{		x = 0;		retn = errNotANumber;	}	else if (x < min || x > max) retn = errOutOfRange;		*value = x;	return retn;}/*****************************************************************************//* 	If it has not been handed a number, it brings up	an appropriate error dialog, inserts an appropriately pinned value,	and selects the item. */  void AlertDouble (DialogPtr dp,				 short item,				 double min,				 double max,				 double *value,				 Handle hDllInstance,				 short alertID,				 short numberErr){ 	Str255 minText = "";	Str255 maxText = "";	short precision = 0;	double x = *value;		// Figure out precision	FetchText(dp, item, minText);	DivideAtDecimal(minText, maxText);	precision = maxText[0]; // no more than number of digits in decimal		x = (x < min ? min : max);	*value = x;			StuffDouble (dp, item, x, precision);	DoubleToString (min, minText, precision);	DoubleToString (max, maxText, precision);		(void) ShowCaution (hDllInstance,						alertID,				  	    kBadDoubleID, // could use numberErr==errNotANumber						minText,	  // to pop a "that's not a number"						maxText);	  // alert.		SelectTextItem (dp, item);}/*****************************************************************************//* Set the state of a check box (or radio button). */void SetCheckBoxState (DialogPtr dp, short item, Boolean checkIt)	{	Rect	r;	Handle	ctl;	short	itemType;	short	oldValue, newValue;		GetDialogItem (dp, item, &itemType, &ctl, &r);	oldValue =  GetCtlValue ((ControlHandle) ctl);		newValue = checkIt ? 1 : 0;	if (oldValue != newValue)		SetCtlValue ((ControlHandle) ctl, newValue);	}/*****************************************************************************//* Determine the state of a check box (or radio button). */Boolean GetCheckBoxState (DialogPtr dp, short item)	{		Rect	r;	Handle	ctl;	short	itemType;	short	oldValue;		GetDialogItem (dp, item, &itemType, &ctl, &r);	oldValue = GetCtlValue ((ControlHandle) ctl);		return (oldValue != 0);		}/*****************************************************************************//* Toggle a check box and return the new state. */Boolean ToggleCheckBoxState (DialogPtr dp, short item)	{		Boolean newState = !GetCheckBoxState (dp, item);		SetCheckBoxState (dp, item, newState);		return newState;		}/*****************************************************************************//* Set a radio group (from first to last item) to reflect the selection. */void SetRadioGroupState (DialogPtr dp,						 short first,						 short last,						 short item)	{	short			i;		for (i = first; i <= last; ++i)		SetCheckBoxState (dp, i, i == item);	}/*****************************************************************************//* Get the selected radio button in a group. */short GetRadioGroupState (DialogPtr dp, short first, short last)	{		short i;		for (i = first; i <= last; ++i)		if (GetCheckBoxState (dp, i))			return i;				return 0;		}/*****************************************************************************//* Set the state of a pop-up menu. */void SetPopUpMenuValue (DialogPtr dp, short item, short newValue)	{	Rect	r;	Handle	ctl;	short	itemType;	short	oldValue;		GetDialogItem (dp, item, &itemType, &ctl, &r);	oldValue =  GetCtlValue ((ControlHandle) ctl);		if (oldValue != newValue)		{		if (GetCtlMax ((ControlHandle) ctl) < newValue)			SetCtlMax ((ControlHandle) ctl, newValue);		SetCtlValue ((ControlHandle) ctl, newValue);		}	}/*****************************************************************************//* Determine the state of a pop-up menu. */short GetPopUpMenuValue (DialogPtr dp, short item)	{		Rect	r;	Handle	ctl;	short	itemType;		GetDialogItem (dp, item, &itemType, &ctl, &r);	return GetCtlValue ((ControlHandle) ctl);		}/*****************************************************************************//* Utility routine to hide or enable an item. */void ShowHideItem (DialogPtr dp, short item, Boolean state){	if (state)		ShowDialogItem(dp, item);	else		HideDialogItem(dp, item);}/*****************************************************************************//* Utility routine to disable a control. */void DisableControl (DialogPtr dp, short item)	{	Rect	r;	Handle	ctl;	short	itemType;	short	oldValue;		GetDialogItem (dp, item, &itemType, &ctl, &r);	itemType |= itemDisable;	oldValue = GetCtlValue ((ControlHandle) ctl);	if (oldValue != 0)		SetCtlValue ((ControlHandle) ctl, 0);	HiliteControl ((ControlHandle) ctl, 255);	SetDialogItem (dp, item, itemType, ctl, &r);	}/*****************************************************************************//* Utility routine to enable a control. */void EnableControl (DialogPtr dp, short item)	{	Rect	r;	Handle	ctl;	short	itemType;		GetDialogItem (dp, item, &itemType, &ctl, &r);	itemType &= ~itemDisable;	HiliteControl ((ControlHandle) ctl, 0);	SetDialogItem (dp, item, itemType, ctl, &r);	}/*****************************************************************************//* Utility routine to enable a control. */void EnableDisableControl (DialogPtr dp, short item, Boolean state)	{		if (state)		EnableControl (dp, item);	else		DisableControl (dp, item);		}/*****************************************************************************//* Utility routine to invalidate an item. */void InvalItem (DialogPtr dp, short item)	{		Rect	r;	Handle	h;	short	itemType;	GrafPtr oldPort;		GetDialogItem (dp, item, &itemType, &h, &r);		GetPort (&oldPort);		SetPort (dp);		InvalRect (&r);		SetPort (oldPort);		}/*****************************************************************************//* Perform standard handling for check boxes and radio buttons. For radio   buttons, we assume that the group for the radio button extends forward   and backward in the DITL as long as the item type is radio button. */   void PerformStandardDialogItemHandling (DialogPtr dp, short item)	{		Rect r;	Handle h;	short itemType;		short first, last, count;		GetDialogItem (dp, item, &itemType, &h, &r);		switch (itemType)		{				case ctrlItem+chkCtrl:			(void) ToggleCheckBoxState (dp, item);			break;					case ctrlItem+radCtrl:			first = last = item;			while (first > 1)				{				GetDialogItem (dp, first - 1, &itemType, &h, &r);				if (itemType != ctrlItem+radCtrl)					break;				--first;				}			count = CountDITL (dp);			while (last < count)				{				GetDialogItem (dp, last + 1, &itemType, &h, &r);				if (itemType != ctrlItem+radCtrl)					break;				++last;				}			SetRadioGroupState (dp, first, last, item);			break;				}		}/*****************************************************************************//* Little routine to flash a button set off by a keystroke. */ void FlashDialogButton (DialogPtr dialog,short  item)	{	short itemType;	Handle h;	Rect r;	GetDItem (dialog, item, &itemType, &h, &r);		if (itemType == (ctrlItem + btnCtrl))		{		long ignore;		HiliteControl ((ControlHandle) h, 1);		Delay (5, &ignore);		HiliteControl ((ControlHandle) h, 0);		}		}/*****************************************************************************//* UserItem to outline the OK button in a dialog box. */static pascal void OutlineOK (DialogPtr dp, short item)	{		PenState originalPenState;	Rect r;	Handle h;	short itemType;		GetPenState (&originalPenState);	item = ok;	GetDItem (dp, item, &itemType, &h, &r);	PenNormal ();	PenSize (3, 3);		InsetRect (&r, -4, -4);	FrameRoundRect (&r, 16, 16);	SetPenState (&originalPenState);		}/*****************************************************************************/#ifdef __powercstatic RoutineDescriptor OutlineOKRDS =	BUILD_ROUTINE_DESCRIPTOR(uppUserItemProcInfo, &OutlineOK);#define OutlineOKRD (&OutlineOKRDS)#else#define OutlineOKRD (&OutlineOK)#endif/*****************************************************************************/void SetOutlineOKHook (DialogPtr dp, short hookItem)	{		short itemType;	Rect r;	Handle h;	GetDItem (dp, hookItem, &itemType, &h				  , &r);	SetDItem (dp, hookItem,  itemType, (Handle) OutlineOKRD, &r);		}